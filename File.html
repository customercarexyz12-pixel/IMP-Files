Slip 1
 (Repeat Q1 in Slip 19)
1.	Take multiple files as Command Line Arguments and print their inode numbers and file types.
#include<stdlib.h> 
#include<stdio.h> 
#include<string.h> 
int main(int argc, char *argv[]) 
{ 
char d[50]; 
if(argc==2) 
{ 
bzero(d,sizeof(d)); 
strcat(d,"ls "); 
strcat(d,"-i "); 
strcat(d,argv[1]); 
system(d); 
} 
else 
printf("\nInvalid No. of inputs"); 
} 
output:
create txt file
1. gcc A1.c
2../a.out File1.txt 
3. cat File1.txt 

2.Write a C program to send SIGALRM signal by child process to parent process and parent process make a provision to catch the signal and display alarm is fired.(Use Kill, fork, signal and sleep system call).
Solution:- 
		
  #include <fcntl.h> 
    #include <unistd.h>
    #include <stdio.h>
    #include<signal.h>
    #include<sys/types.h>
    #include<sys/wait.h>
    #include <stdlib.h> 
void Dingdong()
{ 
printf("Ding!"); 
exit(1); 
} 
int main(int argc, char *argv[]) 
{ 
if(argc!=2) 
{ 
printf("How much seconds you want to sleep the child process\n"); 
} 
int PauseSecond=(argv[1]); 
{ 
if(fork()==0) 
{ 
printf("waiting for alarm to go off\n"); 
printf("%d second pause",PauseSecond); 
sleep(PauseSecond); 
kill(getpid(),SIGALRM); 
} 
else { 
printf("Alarm application starting\n", getpid()); 
signal(SIGALRM,Dingdong); 
printf("done"); 
} 
} 
} 

Slip 2
1.	Write a C program to find file properties such as inode number, number of hard link, File permissions, File size, File access and modification time and so on of a given file using stat() system call.
Solution:  #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
#include<pwd.h> 
#include<grp.h> 
 
int main() 
{ 
 char fn[50],s[500]; 
 struct passwd *pw; 
 struct group *gr; 
 struct stat s1; 
  
 printf("Give File nAME"); 
 gets(fn); 
  
 stat(fn,&s1); 
 if(S_ISREG(s1.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s1.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s1.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s1.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBLK(s1.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s1.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s1.st_mode)) 
  printf(" Link File"); 
   
 printf("\n File permission"); 
 printf((s1.st_mode & S_IRUSR)?"r":"-"); 
 printf((s1.st_mode & S_IWUSR)?"w":"-"); 
 printf((s1.st_mode & S_IXUSR)?"x":"-"); // user per 
  
 printf((s1.st_mode & S_IRGRP)?"r":"-"); 
 printf((s1.st_mode & S_IWGRP)?"w":"-"); 
 printf((s1.st_mode & S_IXGRP)?"x":"-");// group per 
  
 printf((s1.st_mode & S_IROTH)?"r":"-"); 
 printf((s1.st_mode & S_IWOTH)?"w":"-"); 
 printf((s1.st_mode & S_IXOTH)?"x":"-");// other per 
  
 printf("\n Inode Number=.%d",s1.st_ino); // inode number 
  
 printf("\n Number of link=%d",s1.st_nlink); // number of link 
  
 printf("\n size of file=.%d",s1.st_size); // Size 
  
 strcpy(s,ctime(&s1.st_ctime)); 
 printf("\n Creation Time.%s",s); //  creatin time 
  
 strcpy(s,ctime(&s1.st_atime)); 
 printf("\n A Time.%s",s); //  access time 
  
 strcpy(s,ctime(&s1.st_mtime)); 
 printf("\n M Time.%s",s); //  modify time 
  
 printf("\nUsr id:",s1.st_uid);// User id with user name 
 pw=getpwuid(s1.st_uid); 
 printf("User name:%s",pw->pw_name); 
  
 printf("\ngroup id:",s1.st_gid);// Group id with group name 
 gr=getgrgid(s1.st_gid); 
 printf("Group name:%s",gr->gr_name); 
  
 return 0; 
 
}
2.	Write a C program that catches the ctrl-c (SIGINT) signal for the first time and display the appropriate message and exits on pressing ctrl-c again.
Solution: #include<stdio.h>
#include<stdlib.h>
#include<signal.h>
int count=0;
void handler(int sig)
{
    count++;
    if (count==0)
    {
        printf("\n Cltrl c pressed once! Press again to exit \n");
    }
    else{
        printf("\n Cltrl C pressed again! Exiting");
        exit(0);
    }
}
int main()
{
    signal(SIGINT,handler);

    while (1)
    {
        /* code */
    }
    return 0; 
}
Slip 3  (Repeat Q1 in Slip 16)

1.	Print the type of file and inode number where file name accepted through Command Line.
Solution: #include<stdlib.h> 
#include<stdio.h> 
#include<string.h> 
main(int argc, char *argv[]) 
{ 
char d[50]; 
if(argc==2) 
{ 
bzero(d,sizeof(d)); 
strcat(d,"ls "); 
strcat(d,"-i "); 
strcat(d,argv[1]); 
system(d); 
} 
else 
printf("\nInvalid No. of inputs"); 
}

Output: output:
create txt file
1. gcc A1.c
2../a.out File1.txt 
3. cat File1.txt

 (Repeat Q2 in Slip 15)
2.	Write a C program which creates a child process to run linux/ unix command or any user defined program. The parent process set the signal handler for death of child signal and Alarm signal. If a child process does not complete its execution in 5 second then parent process kills child process.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void sh1(); 
void main() 
{ 
 int n; 
 signal(SIGCHLD,sh1); 
 n=fork(); 
 if(n==0) 
 { 
  execlp("ls","ls","-l",NULL); 
 } 
 else 
 { 
  sleep(5); 
  printf("\n child exced time"); 
  kill(n,SIGINT); 
  fflush(stdout); 
  sleep(2); 
 } 
 return 0; 
 
}  
void sh1() 
{ 
 printf("\n child killed by parent"); 
 exit(0); 
}





Slip 4.
1.	Write a C program to find whether a given files passed through command line arguments are present in current directory or not..
Solution: #include<stdio.h> 
#include<unistd.h> 
int main(int argc,char *argv[]) 
{ 
if(access(argv[1],F_OK)==0) 
printf("File %s exists.",argv[1]); 
else 
printf("File not exists."); 
return 0; 
} 

2.	Write a C program which creates a child process and child process catches a signal SIGHUP, SIGINT and SIGQUIT. The Parent process send a SIGHUP or SIGINT signal after every 3 seconds, at the end of 15 second parent send SIGQUIT signal to child and child terminates by displaying message "My Papa has Killed me!!!”. 
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void Sh1(); 
void Sh2(); 
void Sh3(); 
int main() 
{ 
 int n; 
 n=fork(); 
 if(n==0) 
 { 
  signal(SIGHUP,Sh1); 
  signal(SIGINT,Sh2); 
  signal(SIGQUIT,Sh3); 
  while(1) 
  { 
   
  } 
   
 } 
 else 
 { 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGQUIT); 
  exit(0); 
 } 
 return 0; 
} 
 
void Sh1() 
{ 
 printf("\nSIGHUP Process"); 
 //fflush(stdout); 
 signal(SIGHUP,Sh1); 
} 
 
void Sh2() 
{ 
 printf("\n SIGINT Process"); 
 //fflush(stdout); 
 signal(SIGINT,Sh2); 
} 
 
void Sh3() 
{ 
 printf("\n My Papa Has Kill Me"); 
 exit(0); 
} 

Slip 5  (Repeat Q1 in Slip 17)
1.	Read the current directory and display the name of the files, no of files in current directory.
Solution: 

#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
 
int main() 
{ 
 DIR *d; 
 struct dirent *dr;  
 int c=0; 
 d=opendir("."); 
 while(dr=readdir(d)) 
 { 
  printf("\n %s",dr-> d_name); 
  c++; 
 } 
 printf("Count of file %d:",c); 
  closedir(d); 
 return 0; 
}
 (Repeat Q2 in Slip 18)
2.	Write a C program to create an unnamed pipe. The child process will write following three messages to pipe and parent process display it.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2]; 
 int n,i; 
 char *m1="Hello World\n"; 
 char *m2="Hello SPPU\n"; 
 char *m3="Linux is Funny\n"; 
 char s[50]; 
 pipe(p); 
 n=fork(); 
 if(n==0) 
 { 
  write(p[1],m1,strlen(m1)); 
  write(p[1],m2,strlen(m1)); 
  write(p[1],m3,strlen(m1)); 
 } 
 else 
 { 
  printf("\n In Parent!!!!"); 
  for(i=0;i<3;i++) 
  { 
   read(p[0],s,50); 
   printf("%s",s); 
  } 
  
 } 
 
return 0; 
 
}

Slip 6 
(Repeat Q1 in Slip 16)
1.	Display all the files from current directory which are created in particular month.
Solution: #include<stdio.h>
#include<dirent.h>
#include<string.h>
#include<sys/stat.h>
#include<time.h>
#include<stdlib.h>

int main(int argc, char *argv[])
{
    DIR *dp;
    struct dirent *ep;
    struct stat sb;
    char mon[100];
    char *ch, *ch1;

    if (argc != 2) {
        printf("Usage: %s <Month>\n", argv[0]);
        return 1;
    }

    dp = opendir("./");
    if (dp != NULL)
    {
        while ((ep = readdir(dp)) != NULL)
        {
            if (stat(ep->d_name, &sb) == -1)
            {
                perror("stat");
                exit(EXIT_FAILURE);
            }

            strcpy(mon, ctime(&sb.st_ctime));

            // ctime() format: "Wed Jun 05 15:20:10 2024\n"
            // Tokens: Day Month Date Time Year
            ch = strtok(mon, " ");   // "Wed"
            ch = strtok(NULL, " ");  // "Jun"  <-- MONTH

            if (ch != NULL && strcmp(ch, argv[1]) == 0)
            {
                printf("%s\t\t%s", ep->d_name, ctime(&sb.st_ctime));
            }
        }

        closedir(dp);
    }

    return 0;
}

2.	Write a C program to create n child processes. When all n child processes terminates, Display total cumulative time children spent in user and kernel mode.
Solution: 
#include<sys/times.h> 
#include<time.h> 
#include<stdio.h> 
#include<unistd.h> 
#include<sys/wait.h> 
#include<stdlib.h> 
int main() 
{ 
 struct tms t; 
 int c,n,s; 
 long int i,j; 
 double d,ut,st,cut,cst; 
  
 printf("Enter Number of process:"); 
 scanf("%d",&n); 
  
 while(n-- >0) 
 { 
  c=fork(); 
  if(c==0) 
  { 
   printf("\n process id=>%d",getpid()); 
   for(i=0,j>0;i<=10000000;i++) 
   j++; 
   exit(0); 
  } 
  else 
  { 
   wait(&s); 
  } 
 } 
 d=sysconf(_SC_CLK_TCK); 
 times(&t); 
 ut=t.tms_utime/d; 
 st=t.tms_stime/d; 
 cut=t.tms_cutime/d; 
 cst=t.tms_cstime/d; 
  
 printf("\nuser time:-%lf",ut); 
 printf("\nSystem time:-%lf",st); 
 printf(" \nchild user time:-%lf",cut); 
 printf(" \nchild System time:-%lf",cst); 
 return 0; 
}

Slip 7 
1.	Write a C Program that demonstrates redirection of standard output to a file.
Solution: 	#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
int main() 
{ 
 int fd1,fd2; 
 fd1=open("output.txt",O_WRONLY|O_CREAT,0666); 
 printf("\nNormal output:"); 
 fflush(stdout); 
  
fd2=dup(1);
dup2(fd1,1);
printf("\n Atharav Nijampurkar");
printf("\n h.v.deasi clg");
  
 close(fd1); 
 fflush(stdout); 
 dup2(fd2,1); 
 printf("\nAgain Normal"); 
 return 0; 
}
	(Repeat Q1 in Slip 7,8,19)
2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { 
  close(p[1]); 
  close(0); 
  dup(p[0]); 
  close(p[0]); 
  execlp("wc","wc","-l",NULL); 
 }  
 return 0; 
  
}

Slip 8
(Repeat Q1 in Slip 11)
1.	Write a C program that redirects standard output to a file output.txt. (use of dup and open system call).
Solution: #include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
int main() 
{ 
 int fd1,fd2; 
 fd1=open("output.txt",O_WRONLY|O_CREAT,0666); 
 printf("\nNormal output:"); 
 fflush(stdout); 
  
 fd2=dup(1); 
 dup2(fd1,1); 
 printf("\n Atharav Nijampurkar"); 
 printf("\n h.v.deasi clg"); 
  
 close(fd1); 
 fflush(stdout); 
 dup2(fd2,1); 
 printf("\nAgain Normal"); 
 return 0; 
  
}

2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: Repeat in slip 7.

Slip 9
1.	Generate parent process to write unnamed pipe and will read from it.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2]; 
 int n,i; 
 char *m1="Atharav Nijampurkar\n"; 
 char *m2="photographer\n"; 
 char *m3="pune\n"; 
 char s[100]; 
 pipe(p); 
 n=fork(); 
 if(n==0) 
 { 
  write(p[1],m1,strlen(m1)); 
  write(p[1],m2,strlen(m1)); 
  write(p[1],m3,strlen(m1)); 
 } 
 else 
 { 
  printf("\n In Parent!!!!"); 
  for(i=0;i<3;i++) 
  { 
   read(p[0],s,100); 
   printf("%s",s); 
  } 
  
 } 
 
return 0; 
 
}
	(Solution: Repeat in slip 20)
2.	Write a C program to Identify the type (Directory, character device, Block device, Regular file, FIFO or pipe, symbolic link or socket) of given file using stat() system call.
Solution 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
 
int main( int argc,char *argv[]) 
 { 
  struct stat s; 
 int i; 
 if(argc<=0) 
 { 
  printf("Give File name"); 
  exit(0); 
 } 
 stat(argv[i],&s); 
 if(S_ISREG(s.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBL///K(s.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s.st_mode)) 
  printf(" Link File"); 
   
 return 0; 
}
Slip 10
1.	Write a program that illustrates how to execute two commands concurrently with a pipe.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ char s[80]; 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { wait(); 
  printf("Im in parent"); 
  while(read(p[0],s,80)) 
  printf("%s",s); 
  exit(n); 
 } 
  
 return 0; 
  
}

2.	Generate parent process to write unnamed pipe and will write into it. Also generate child process which will read from pipe.
Solution: #include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h>
#include<string.h> 
int main() { 
    int pipe_fd[2]; // File descriptors for the pipe  
    // Create the pipe 
    if (pipe(pipe_fd) == -1) { 
        perror("Pipe creation failed"); 
        exit(EXIT_FAILURE); 
    } 
    pid_t child_pid = fork(); // Fork a child process 
    if (child_pid == -1) { 
        perror("Fork failed"); 
        exit(EXIT_FAILURE); 
    } 
    if (child_pid == 0) { 
        // Child process 
        close(pipe_fd[1]); // Close the write end of the pipe in the child process 
        char buffer[100]; 
        ssize_t bytes_read = read(pipe_fd[0], buffer, sizeof(buffer)); 
        close(pipe_fd[0]); // Close the read end of the pipe in the child process 
        if (bytes_read == -1) { 
            perror("Read from pipe failed"); 
            exit(EXIT_FAILURE); 
        } 
        printf("Child received: %.*s\n", (int)bytes_read, buffer); 
 
    } else { 
        // Parent process 
        close(pipe_fd[0]); // Close the read end of the pipe in the parent process 
        const char *message = "Hello from parent!"; 
        ssize_t bytes_written = write(pipe_fd[1], message, strlen(message)); 
        close(pipe_fd[1]); // Close the write end of the pipe in the parent process 
        if (bytes_written == -1) { 
            perror("Write to pipe failed"); 
            exit(EXIT_FAILURE); 
        } 
        printf("Parent sent: %s\n", message); 
    } 
    return 0; 
}

Slip 11
1.	Write a C program to get and set the resource limits such as files, memory associated with a process.
Solution:- #include <stdio.h> 
#include <stdlib.h> 
#include <sys/resource.h> 
 
void printLimits() { 
    struct rlimit limits; 
 
    // Get the current resource limits for file descriptors 
    if (getrlimit(RLIMIT_NOFILE, &limits) == -1) { 
        perror("getrlimit for RLIMIT_NOFILE failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    printf("Current maximum file descriptors limit: %ld\n", (long)limits.rlim_cur); 
 
    // Get the current resource limits for stack size 
    if (getrlimit(RLIMIT_STACK, &limits) == -1) { 
        perror("getrlimit for RLIMIT_STACK failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    printf("Current maximum stack size limit: %ld bytes\n", (long)limits.rlim_cur); 
} 
 
void setLimits() { 
    struct rlimit new_limits; 
 
    // Set the new maximum file descriptors limit 
    new_limits.rlim_cur = 1024;  // Set to the desired value 
    new_limits.rlim_max = 1024;  // Set to the same value as rlim_cur for simplicity 
 
    if (setrlimit(RLIMIT_NOFILE, &new_limits) == -1) { 
        perror("setrlimit for RLIMIT_NOFILE failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    printf("New maximum file descriptors limit set: %ld\n", (long)new_limits.rlim_cur); 
 
    // Set the new maximum stack size limit 
    new_limits.rlim_cur = 1024 * 1024 * 2;  // Set to the desired value (2 MB) 
    new_limits.rlim_max = 1024 * 1024 * 2;  // Set to the same value as rlim_cur for simplicity 
 
    if (setrlimit(RLIMIT_STACK, &new_limits) == -1) { 
        perror("setrlimit for RLIMIT_STACK failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    printf("New maximum stack size limit set: %ld bytes\n", (long)new_limits.rlim_cur); 
} 
 
int main() { 
    printf("Before setting limits:\n"); 
    printLimits(); 
 
    printf("\nSetting new limits:\n"); 
    setLimits(); 
 
    printf("\nAfter setting limits:\n"); 
    printLimits(); 
 
    return 0; 
}

2.	Write a C program that redirects standard output to a file output.txt. (use of dup and open system call).
Solution:  Repeat in Slip No. 8

Slip 12.
1.	Write a C program that print the exit status of a terminated child process.
Solution: 
#include<sys/times.h> 
#include<time.h> 
#include<stdio.h> 
#include<unistd.h> 
#include<sys/wait.h> 
 
int main() 
{ 
 int n,s,c; 
 c=fork(); 
 if(c==0) 
 { 
  execlp("date","date",NULL); 
   
 } 
 else 
 { 
  waitpid(c,&s,WNOHANG); 
  if(WIFEXITED(s)) 
  { 
   printf("\n Exit status=>%d",WEXITSTATUS(s)); 
  } 
 } 
 return 0; 
}

2.	Write a C program which receives file names as command line arguments and display those filenames in ascending order according to their sizes. I) (e.g $ a.out a.txt b.txt c.txt, …).
Solution: #include <stdio.h> 
#include <stdlib.h> 
#include <sys/stat.h> 
 
// Structure to hold file information 
struct FileInfo { 
    char *name; 
    off_t size; 
}; 
 
// Function to compare two FileInfo structures by size 
int compareFileInfo(const void *a, const void *b) { 
    return ((struct FileInfo *)a)->size - ((struct FileInfo *)b)->size; 
} 
 
int main(int argc, char *argv[]) { 
    // Check if at least one file name is provided 
    if (argc < 2) { 
        fprintf(stderr, "Usage: %s file1 file2 file3 ...\n", argv[0]); 
        return EXIT_FAILURE; 
    } 
 
    // Allocate an array of FileInfo structures 
    struct FileInfo *files = (struct FileInfo *)malloc((argc - 1) * sizeof(struct FileInfo)); 
 
    // Populate the array with file names and sizes 
    for (int i = 1; i < argc; ++i) { 
        files[i - 1].name = argv[i]; 
 
        struct stat fileStat; 
        if (stat(argv[i], &fileStat) == -1) { 
            perror("Error getting file size"); 
            return EXIT_FAILURE; 
        } 
 
        files[i - 1].size = fileStat.st_size; 
    } 
 
    // Sort the array of FileInfo structures based on file size 
    qsort(files, argc - 1, sizeof(struct FileInfo), compareFileInfo); 
    // Display the sorted file names 
    printf("File names in ascending order based on size:\n"); 
    for (int i = 0; i < argc - 1; ++i) { 
        printf("%s - %ld bytes\n", files[i].name, (long)files[i].size); 
    } 
 
    // Free the allocated memory 
    free(files); 
 
    return EXIT_SUCCESS; 
}

Slip 13
	(Repeat in Slip 20)
1.	Write a C program that illustrates suspending and resuming processes using signals.
Solution: #include<stdio.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<signal.h> 
void sh1(); 
void sh2(); 
void sh3(); 
int main() 
{ 
printf("\nIn main Program"); 
signal(SIGTSTP,sh1); 
signal(SIGCONT,sh2); 
signal(SIGINT,sh3); 
while(1) 
{ 
sleep(2); 
raise(SIGTSTP); 
sleep(2); 
raise(SIGCONT); 
} 
return 0; 
} 
void sh1() 
{ 
printf("\nSuspend"); 
} 
void sh2() 
{ 
printf("\nResume"); 
} 
void sh3() 
{ 
printf("\nIntrupted"); 
exit(0); 
}

2.	Write a C program that a string as an argument and return all the files that begins with that name in the current directory. For example > ./a.out foo will return all file names that begins with foo.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
 
int main( int argc,char *argv[]) 
{ 
 DIR *d; 
  struct dirent *dr;  
  char t[50]; 
  d=opendir("."); 
  if(argc<=1) 
  { 
   printf("Enter name"); 
   exit(0); 
  } 
  while(dr=readdir(d)) 
  { 
  strncpy(t,dr->d_name,strlen(argv[1])); 
  if(strcmp(t,argv[1])==0) 
   printf("\n%s",dr->d_name); 
   
  } 
  closedir(d); 
  return 0;  
 
}

Slip 14
1.	 Display all the files from current directory whose size is greater that n Bytes Where n is accept from user.
Solution:  #include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>

int main()
{
    DIR *dp;
    struct dirent *entry;
    struct stat fileStat;
    long n;

    printf("Enter size in bytes (N): ");
    scanf("%ld", &n);

    dp = opendir("./");
    if (dp == NULL) {
        perror("opendir");
        return 1;
    }

    printf("\nFiles larger than %ld bytes:\n\n", n);

    while ((entry = readdir(dp)) != NULL)
    {
        if (stat(entry->d_name, &fileStat) == -1)
            continue;

        // Check if it is a regular file
        if (S_ISREG(fileStat.st_mode))
        {
            if (fileStat.st_size > n)
            {
                printf("%-20s  %ld bytes\n", entry->d_name, fileStat.st_size);
         }
        }
    }

    closedir(dp);
    return 0;
}
2.	Write a C program to find file properties such as inode number, number of hard link, File permissions, File size, File access and modification time and so on of a given file using stat() system call.
Solution: #include <fcntl.h> 
    #include <unistd.h>
    #include <stdio.h>
    #include<signal.h>
    #include<sys/types.h>
    #include<sys/wait.h>
    #include <stdlib.h> 
void Dingdong()
{ 
printf("Ding!"); 
exit(1); 
} 
int main(int argc, char *argv[]) 
{ 
if(argc!=2) 
{ 
printf("How much seconds you want to sleep the child process\n"); 
} 
int PauseSecond=(argv[1]); 
{ 
if(fork()==0) 
{ 
printf("waiting for alarm to go off\n"); 
printf("%d second pause",PauseSecond); 
sleep(PauseSecond); 
kill(getpid(),SIGALRM); 
} 
else { 
printf("Alarm application starting\n", getpid()); 
signal(SIGALRM,Dingdong); 
printf("done"); 
} 
} 
} 
Slip 15
1.	Display all the files from current directory whose size is greater that n Bytes Where n is accept from user.
Solution: Repeat in Slip 14

2.	Write a C program which creates a child process to run linux/ unix command or any user defined program. The parent process set the signal handler for death of child signal and Alarm signal. If a child process does not complete its execution in 5 second then parent process kills child process.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void sh1(); 
void main() 
{ 
 int n; 
 signal(SIGCHLD,sh1); 
 n=fork(); 
 if(n==0) 
 { 
  execlp("ls","ls","-l",NULL); 
 } 
 else 
 { 
  sleep(5); 
  printf("\n child exced time"); 
  kill(n,SIGINT); 
  fflush(stdout); 
  sleep(2); 
 } 
 return 0; 
 
}  
void sh1() 
{ 
 printf("\n child killed by parent"); 
 exit(0); 
}

Slip 16
1.	Display all the files from current directory which are created in particular month.
Solution: #include<stdio.h>
#include<dirent.h>
#include<string.h>
#include<sys/stat.h>
#include<time.h>
#include<stdlib.h>

int main(int argc, char *argv[])
{
    DIR *dp;
    struct dirent *ep;
    struct stat sb;
    char mon[100];
    char *ch, *ch1;

    if (argc != 2) {
        printf("Usage: %s <Month>\n", argv[0]);
        return 1;
    }

    dp = opendir("./");
    if (dp != NULL)
    {
        while ((ep = readdir(dp)) != NULL)
        {
            if (stat(ep->d_name, &sb) == -1)
            {
                perror("stat");
                exit(EXIT_FAILURE);
            }

            strcpy(mon, ctime(&sb.st_ctime));

            // ctime() format: "Wed Jun 05 15:20:10 2024\n"
            // Tokens: Day Month Date Time Year
            ch = strtok(mon, " ");   // "Wed"
            ch = strtok(NULL, " ");  // "Jun"  <-- MONTH

            if (ch != NULL && strcmp(ch, argv[1]) == 0)
            {
                printf("%s\t\t%s", ep->d_name, ctime(&sb.st_ctime));
            }
        }
        closedir(dp);
    }
    return 0;
}
2.	Write a C program which create a child process which catch a signal sighup, sigint and sigquit. The Parent process send a sighup or sigint signal after every 3 seconds, at the end of 30 second parent send sigquit signal to child and child terminates my displaying message “My DADDY has Killed me!!!”.
Solution:  #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void Sh1(); 
void Sh2(); 
void Sh3(); 
int main() 
{ 
 int n; 
 n=fork(); 
 if(n==0) 
 { 
  signal(SIGHUP,Sh1); 
  signal(SIGINT,Sh2); 
  signal(SIGQUIT,Sh3); 
  while(1) 
  { 
   
  } 
   
 } 
 else 
 { 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGQUIT); 
  exit(0); 
 } 
 return 0; 
} 
 
void Sh1() 
{ 
 printf("\nSIGHUP Process"); 
 //fflush(stdout); 
 signal(SIGHUP,Sh1); 
} 
 
void Sh2() 
{ 
 printf("\n SIGINT Process"); 
 //fflush(stdout); 
 signal(SIGINT,Sh2); 
} 
 
void Sh3() 
{ 
 printf("\n My DADDY Has Kill Me"); 
 exit(0); 
}

Slip 17
1.	Read the current directory and display the name of the files, no of files i.
Solution: Repeat in slip 5

2.	Write a C program to implement the following unix/linux command (use fork, pipe and exec system call). Your program should block the signal Ctrl-C and Ctrl-\ signal during the execution. i. Ls –l | wc –l
Solution:  #include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

int main() 
{
    int fd[2];
    pid_t p1, p2;

    // Block Ctrl-C (SIGINT) and Ctrl-\ (SIGQUIT)
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }

    // First child : executes "ls -l"
    p1 = fork();
    if (p1 == 0) {
        // Child 1
        signal(SIGINT, SIG_IGN);
        signal(SIGQUIT, SIG_IGN);

        close(fd[0]);                // Close reading end
        dup2(fd[1], STDOUT_FILENO);  // Redirect stdout to pipe write end
        close(fd[1]);

        execl("/bin/ls", "ls", "-l", NULL);
        perror("execl failed");
        exit(1);
    }

    // Second child : executes "wc -l"
    p2 = fork();
    if (p2 == 0) {
        // Child 2
        signal(SIGINT, SIG_IGN);
        signal(SIGQUIT, SIG_IGN);

        close(fd[1]);                // Close writing end
        dup2(fd[0], STDIN_FILENO);   // Redirect stdin to pipe read end
        close(fd[0]);

        execl("/usr/bin/wc", "wc", "-l", NULL);
        perror("execl failed");
        exit(1);
    }

    // Parent process
    close(fd[0]);
    close(fd[1]);

    // Restore normal signal behavior AFTER work is done
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);

    wait(NULL);
    wait(NULL);

    return 0;
}
	Slip 18
1.	Write a C program to find whether a given file is present in current directory or not.
Solution. #include<stdio.h> 
#include<unistd.h> 
int main(int argc,char *argv[]) 
{ 
if(access(argv[1],F_OK)==0) 
printf("File %s exists.",argv[1]); 
else 
printf("File not exists."); 
return 0; 
}

2.	Write a C program to create an unnamed pipe. The child process will write following three messages to pipe and parent process display it. Message1 = “Hello World” Message2 = “Hello SPPU” Message3 = “Linux is Funny”.
Solution: (Repeat in slip 5)

Slip 19:
1.	Take multiple files as Command Line Arguments and print their inode numbers and file types.
Solution: Repeat on slip 1

2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: Repeat on slip 8

Slip 20 
1.	Write a C program that illustrates suspending and resuming processes using signals.
Solution: Repeat on slip 13

2.	Write a C program that a string as an argument and return all the files that begins with that name in the current directory. For example > ./a.out foo will return all file names that begins with foo.
Solution: Repeat on slip 13
 

