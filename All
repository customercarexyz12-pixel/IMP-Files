Slip 1. 

1.Write a Python program to implement Depth First Search algorithm. Refer the following graph as an 
Input for the program. [Initial node=1,Goal node=8] 
# Graph represented as an adjacency list 
graph = { 
1: [2, 3], 
2: [1, 4, 5], 
3: [1, 6, 7], 
4: [2, 8], 
5: [2, 8], 
6: [3, 8], 
7: [3, 8], 
8: [4, 5, 6, 7] 
} 
def dfs(graph, start, goal, visited=None): 
if visited is None: 
visited = set() 
# Markthe current node as visited 
visited.add(start) 
print(f"Visiting node: {start}") 
# Check if the current node is the goal 
if start == goal: 
print(f"Goal node {goal} found!") 
return True 
# Explore the neighbors 
for neighbor in graph[start]: 
if neighbor not in visited: 
if dfs(graph, neighbor, goal, visited): 
return True 
return False 
# Initial node and goal node 
initial_node = 1 
goal_node = 8 
# Running the DFS algorithm 
if not dfs(graph, initial_node, goal_node): 
print(f"Goal node {goal_node} not found.") 


2.  Write a python program implement tic-tac-toe. 
Write a program to play tic-tac-toe game (Game theory) 
board=["-","-","-","-","-","-","-","-","-",] 
def printb(): 
print(board[0]+"|"+board[1]+"|"+board[2]) 
print("-"*6) 
print(board[3]+"|"+board[4]+"|"+board[5]) 
print("-"*6) 
print(board[6]+"|"+board[7]+"|"+board[8]) 
def start(): 
player='X' 
go=False 
while not go: 
printb() 
take_turn(player) 
result=game_over() 
if result=="WIN": 
print(player+"win") 
go=True 
if result=="Tie": 
print("Tie") 
go=True 
else: 
if player=="X": 
player="O" 
else: 
player="X" 
def game_over(): 
if(board[0]==board[1]==board[2]!="-")or(board[3]==board[4]==board[5]!="- 
")or(board[6]==board[7]==board[8]!="-")or(board[0]==board[3]==board[6]!="- 
")or(board[1]==board[4]==board[7]!="-")or(board[2]==board[5]==board[8]!="- 
")or(board[0]==board[4]==board[8]!="-")or(board[2]==board[4]==board[6]!="-"): 
return "WIN" 
if "-" not in board: 
return"Tie" 
else: 
return "play" 
def take_turn(player): 
pos=input("enter position between1-9:-") 
while pos not in["1","2","3","4","5","6","7","8","9"]: 
pos=input("enter valid position:-") 
pos=int(pos)-1 
while board[pos]!="-": 
pos=input("enter new position between1-9:-") 
board[pos]=player 
start() 


Slip 2. 
Write a Python program to implement Breadth First Search algorithm. Refer the following graph as an 
Input for the program. [Initial node=1,Goal node=8] 
from collections import deque 
# Graph represented as an adjacency list 
graph = { 
1: [2, 3], 
2: [1, 4, 5], 
3: [1, 6, 7], 
4: [2, 8], 
5: [2, 8], 
6: [3, 8], 
7: [3, 8], 
8: [4, 5, 6, 7] 
} 
def bfs(graph, start, goal): 
# Queuefor BFS and a set for visited nodes 
queue = deque([start]) 
visited = set() 
visited.add(start) 
while queue: 
current = queue.popleft() 
print(f"Visiting node: {current}") 
# Check if the current node is the goal 
if current == goal: 
print(f"Goal node {goal} found!") 
return True 
# Addunvisited neighbors to the queue 
for neighbor in graph[current]: 
if neighbor not in visited: 
visited.add(neighbor) 
queue.append(neighbor) 
print(f"Goal node {goal} not found.") 
return False 
# Initial node and goal node 
initial_node = 1 
goal_node = 8 
# Running the BFS algorithm 
bfs(graph, initial_node, goal_node) 


2. Write a python program to implement cryptarithmetic problem SEND+MORE=MONEY. 
Write a python program for cryptarithmetic problem SEND+MORE=MONEY 
def solve1(): 
for s in range(1, 10): 
for e in range(0, 10): 
for n in range(0, 10): 
for d in range(0, 10): 
for m in range(1, 10): 
for o in range(0, 10): 
for r in range(0, 10): 
for y in range(0, 10): 
if distinct(s, e, n, d, m, o, r, y): 
send = 1000 * s + 100 * e + 10 * n + d 
more = 1000 * m + 100 * o + 10 * r + e 
money = 10000 * m + 1000 * o + 100 * n + 10 * e + y 
if send + more == money: 
return send, more, money 
def distinct(*args): 
return len(set(args)) == len(args) 
print(solve1()) 


Slip 3. 
1.Write a Python program to solve water jug problem. 2 jugs with capacity 5 gallon and  
7 gallon are given with unlimited water supply respectively. The target to achieve is  
4 gallon of water in second jug. 
from collections import deque 
def water_jug_problem(capacity1, capacity2, target): 
# Queuefor BFS 
queue = deque() 
# Set to keep track of visited states 
visited = set() 
# Initial state: (jug1, jug2) 
initial_state = (0, 0) 
queue.append((initial_state, [])) # (state, path) 
visited.add(initial_state) 
while queue: 
(jug1, jug2), path = queue.popleft() 
# Addthe current state to the path 
path.append((jug1, jug2)) 
# Check if we reached the goal 
if jug2 == target: 
return path 
# Possible actions: 
possible_states = [ 
(capacity1, jug2), # Fill jug1 
(jug1, capacity2), # Fill jug2 
(0, jug2), 
# Empty jug1 
(jug1, 0), 
# Empty jug2 
(min(jug1 + jug2, capacity1), jug2- (capacity1- jug1) if jug1 + jug2 > capacity1 else 0), # Pour jug2 
to jug1 
(jug1- (capacity2- jug2) if jug1 + jug2 > capacity2 else 0, min(jug1 + jug2, capacity2)) # Pour jug1 
to jug2 
] 
for state in possible_states: 
if state not in visited: 
visited.add(state) 
queue.append((state, path.copy())) 
return None # No solution found 
def print_solution(solution): 
if solution is None: 
print("No solution found.") 
else: 
print("Steps to achieve target:") 
for step in solution: 
print(f"Jug 1: {step[0]} gallons, Jug 2: {step[1]} gallons") 
if __name__ == "__main__": 
capacity1 = 5 # Capacity of jug1 
capacity2 = 7 # Capacity of jug2 
target = 4 #Target amount in jug2 
solution = water_jug_problem(capacity1, capacity2, target) 
print_solution(solution) 


2. Write a python program to implement cryptarithmetic problem BASE + BALL = GAMES 
import itertools 
def solve_cryptarithm(): 
letters = ('B', 'A', 'S', 'E', 'L', 'G', 'M') 
digits = range(10) 
 
    for perm in itertools.permutations(digits, len(letters)): 
        assign = dict(zip(letters, perm)) 
 
        # Leading digit cannot be zero 
        if assign['B'] == 0 or assign['G'] == 0: 
            continue 
 
        # Convert words to numbers 
        BASE  = assign['B']*1000 + assign['A']*100 + assign['S']*10 + assign['E'] 
        BALL  = assign['B']*1000 + assign['A']*100 + assign['L']*10 + assign['L'] 
        GAMES = assign['G']*10000 + assign['A']*1000 + assign['M']*100 + assign['E']*10 + assign['S'] 
 
        # Check equation 
        if BASE + BALL == GAMES: 
            print("Solution Found!") 
            print(assign) 
            print(f"{BASE} + {BALL} = {GAMES}") 
            return 
 
    print("No solution found.") 
 
solve_cryptarithm() 



Slip 4. 
1. Write a Python program to demonstrate List operations. 
# To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1) 


2. Write a python program to implement 4 Queen Problem 
def print_solution(board): 
"""Print the chessboard configuration.""" 
for row in board: 
print(" ".join("Q" if col else "." for col in row)) 
print() 
def is_safe(board, row, col): 
"""Check if a queen can be placed at board[row][col].""" 
# Check this row on left side 
for i in range(col): 
if board[row][i] == 1: 
return False 
# Check upper diagonal on left side 
for i, j in zip(range(row,-1,-1), range(col,-1,-1)): 
if board[i][j] == 1: 
return False 
# Check lower diagonal on left side 
for i, j in zip(range(row, len(board)), range(col,-1,-1)): 
if board[i][j] == 1: 
return False 
return True 
def solve_n_queens_util(board, col): 
"""Utilize backtracking to solve the N-Queens problem.""" 
if col >= len(board): 
print_solution(board) 
return True 
for i in range(len(board)): 
if is_safe(board, i, col): 
board[i][col] = 1 # Place queen 
# Recur to place the rest of the queens 
solve_n_queens_util(board, col + 1) 
# Backtrack 
board[i][col] = 0 # Remove queen 
return False 
def solve_n_queens(n): 
"""Solve the N-Queens problem and print all solutions.""" 
board = [[0 for _ in range(n)] for _ in range(n)] 
if not solve_n_queens_util(board, 0): 
print("No solution exists.") 
if __name__ == "__main__": 
n =4 #Sizeoftheboard (4x4 for the 4-Queens problem) 
solve_n_queens(n) 

Slip 5. 
1. Write a Python program to demonstrate Set operations. 
# Create a Set:  
thisset = {"apple", "banana", "cherry"}  
print(thisset)  
# Find length of the set using len() function  
print(len(thisset))  
# Add an item to a set, using the add() method:  
thisset = {"apple", "banana", "cherry"}  
thisset.add("orange")  
print(thisset)  
# Add elements from tropical into thisset:  
thisset = {"apple", "banana", "cherry"}  
tropical = {"pineapple", "mango", "papaya"}  
thisset.update(tropical)  
print(thisset)  
# Remove "banana" by using the remove() method:  
thisset = {"apple", "banana", "cherry"}  
thisset.remove("banana")  
print(thisset)  
# Set intersection() Method  
x = {"apple", "banana", "cherry"}  
y = {"google", "microsoft", "apple"}  
z = x.intersection(y)  
print(z)  
# Set union() Method  
x = {"apple", "banana", "cherry"}  
y = {"google", "microsoft", "apple"}  
z = x.union(y)  
print(z)  
# Set issubset() Method  
x = {"a", "b", "c"}  
y = {"f", "e", "d", "c", "b", "a"}  
z = x.issubset(y)  
print(z) 


2. Write a python program to implement N Queen Problem 
N = 4 # (size of the chessboard)  
def solveNQueens(board, col):  
if col == N:  
print(board)  
return True  
for i in range(N):  
if isSafe(board, i, col):  
board[i][col] = 1  
if solveNQueens(board, col + 1):  
return True  
board[i][col] = 0  
return False  
def isSafe(board, row, col):  
for x in range(col):  
if board[row][x] == 1:  
return False  
for x, y in zip(range(row, -1, -1), range(col, -1, -1)):  
if board[x][y] == 1:  
return False  
for x, y in zip(range(row, N, 1), range(col, -1, -1)):  
if board[x][y] == 1:  
return False  
return True  
board = [[0 for x in range(N)] for y in range(N)]  
if not solveNQueens(board, 0):  
print("No solution found") 


Slip 6. 
1. Write a Python program to demonstrate List operations. 
# To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1) 


2. Write a python program to implement tower of Hanoi 
def toh(disks, source, auxiliary, target):    
if(disks == 1):    
print('Move disk 1 from rod {} to rod {}.'.format(source, target))    
return    
toh(disks - 1, source, target, auxiliary)    
print('Move disk {} from rod {} to rod {}.'.format(disks, source, target))    
toh(disks - 1, auxiliary, source, target)    
disks = int(input('Enter the number of disks: '))    
toh(disks, 'A', 'B', 'C') 


Slip 7. 
1. Write a Python program to demonstrate List operations. 
# To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1) 


2. Write Python program to implement crypt arithmetic problem TWO+TWO=FOUR 
from itertools import permutations 
def is_valid_assignment(T, W, O, F, U, R): 
"""Check if the assignment is valid for the equation TWO + TWO = FOUR.""" 
two =T*100+W*10+O 
four = F * 1000 +O*100+U*10+R 
return two + two == four 
def solve_cryptarithmetic(): 
letters = 'TWOFRU' 
unique_letters = set(letters) 
for perm in permutations(range(10), len(unique_letters)): 
# Create a mapping from letters to digits 
mapping = dict(zip(unique_letters, perm)) 
T =mapping['T'] 
W=mapping['W'] 
O=mapping['O'] 
F =mapping['F'] 
U=mapping['U'] 
R =mapping['R'] 
# Ensure leading digits are not zero 
if T != 0 and F != 0: 
if is_valid_assignment(T, W, O, F, U, R): 
print(f"T={T}, W={W}, O={O}, F={F}, U={U}, R={R}") 
print(f"{T}{W}{O} + {T}{W}{O} = {F}{O}{U}{R}") 
# Runthe solver 
if __name__ == "__main__": 
solve_cryptarithmetic() 


Slip 8. 
1. Write a python program to implement minimax algorithm 
def minimax (curDepth, nodeIndex,maxTurn, scores, targetDepth):  
if (curDepth == targetDepth):   
return scores[nodeIndex]  
if (maxTurn):  
return max(minimax(curDepth + 1, nodeIndex * 2, False, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, False, scores, targetDepth))  
else:  
return min(minimax(curDepth + 1, nodeIndex * 2, True, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, True, scores, targetDepth))  
scores = [3, 5, 2, 9, 12, 5, 23, 23]  
treeDepth = math.log(len(scores), 2)  
print("The optimal value is : ", end = "")  
print(minimax(0, 0, True, scores, treeDepth)) 
 
2. Write a Python program to simulate 8-Queens problem 
N = 8 # (size of the chessboard)  
   
def solveNQueens(board, col):  
    if col == N:  
        print(board)  
        return True  
    for i in range(N):  
        if isSafe(board, i, col):  
            board[i][col] = 1  
            if solveNQueens(board, col + 1):  
                return True  
            board[i][col] = 0  
    return False  
   
def isSafe(board, row, col):  
    for x in range(col):  
        if board[row][x] == 1:  
            return False  
    for x, y in zip(range(row, -1, -1), range(col, -1, -1)):  
        if board[x][y] == 1:  
            return False  
    for x, y in zip(range(row, N, 1), range(col, -1, -1)):  
        if board[x][y] == 1:  
            return False  
    return True  
   
board = [[0 for x in range(N)] for y in range(N)]  
if not solveNQueens(board, 0):  
    print("No solution found") 
 
Slip 9. 
1. Write a python program to implement DFS algorithm 
# DFS Program (Depth First Search) 
 
d = { 
'A': ['B', 'C'], 
'B': ['D', 'E'], 
'C': ['F', 'G'], 
'D': ['H', 'I'], 
'E': [], 
'F': ['K'], 
'G': [], 
'H': [], 
'I': [], 
'K': [] 
} 
visited = set() 
def dfs(graph, visited, node): 
if node not in visited: 
print(node, end=" ") 
visited.add(node) 
for neigh in graph[node]: 
dfs(graph, visited, neigh) 
print("DFS Traversal:") 
dfs(d, visited, 'A') 

2. Write a Program to Implement Tower of Hanoi using Python 
def toh(disks, source, auxiliary, target):    
if(disks == 1):    
print('Move disk 1 from rod {} to rod {}.'.format(source, target))    
return    
toh(disks - 1, source, target, auxiliary)    
print('Move disk {} from rod {} to rod {}.'.format(disks, source, target))    
toh(disks - 1, auxiliary, source, target)    
disks = int(input('Enter the number of disks: '))    
toh(disks, 'A', 'B', 'C') 

Slip 10. 
Write a python program to implement BFS algorithm 
d = { 
'A': ['B', 'C'], 
'B': ['D', 'E'], 
'C': ['F', 'G'], 
    'D': [], 
    'E': [], 
    'F': ['H', 'I'], 
    'G': [], 
    'H': [], 
    'I': [] 
} 
 
visited = [] 
queue = [] 
 
def bfs(d, visited, node): 
    visited.append(node) 
    queue.append(node) 
 
    while queue: 
        p = queue.pop(0) 
        print(p) 
 
        for neigh in d[p]: 
            if neigh not in visited: 
                visited.append(neigh) 
                queue.append(neigh) 
 
print("BFS =>") 
bfs(d, visited, 'A') 
 
2. Write a Program to Implement Tie Tac Toe problem 
board=["-","-","-","-","-","-","-","-","-",]  
def printb():  
 print(board[0]+"|"+board[1]+"|"+board[2])  
 print("-"*6)  
 print(board[3]+"|"+board[4]+"|"+board[5])  
 print("-"*6)  
 print(board[6]+"|"+board[7]+"|"+board[8])  
   
def start():  
 player='X'  
 go=False  
 while not go:  
  printb()  
  take_turn(player)  
result=game_over()  
if result=="WIN":  
print(player+"win")  
go=True  
if result=="Tie":  
print("Tie")  
go=True  
else:  
if player=="X":  
player="O"  
else:  
player="X"  
def game_over():  
if(board[0]==board[1]==board[2]!="-")or(board[3]==board[4]==board[5]!=" 
")or(board[6]==board[7]==board[8]!="-")or(board[0]==board[3]==board[6]!=" 
")or(board[1]==board[4]==board[7]!="-")or(board[2]==board[5]==board[8]!=" 
")or(board[0]==board[4]==board[8]!="-")or(board[2]==board[4]==board[6]!="-"):  
return "WIN"  
if "-" not in board:  
return"Tie"  
else:  
return "play"  
def take_turn(player):  
pos=input("enter position between1-9:-")  
while pos not in["1","2","3","4","5","6","7","8","9"]:  
pos=input("enter valid position:-")  
pos=int(pos)-1  
while board[pos]!="-":  
pos=input("enter  new position between1-9:-")  
board[pos]=player  
start() 


Slip 11. 
1. Write a Python program to implement Mini-Max Algorithm. 
def minimax (curDepth, nodeIndex,maxTurn, scores, targetDepth):  
if (curDepth == targetDepth):   
return scores[nodeIndex]  
if (maxTurn):  
return max(minimax(curDepth + 1, nodeIndex * 2, False, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, False, scores, targetDepth))  
else:  
return min(minimax(curDepth + 1, nodeIndex * 2, True, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, True, scores, targetDepth))  
scores = [3, 5, 2, 9, 12, 5, 23, 23]  
treeDepth = math.log(len(scores), 2)  
print("The optimal value is : ", end = "")  
print(minimax(0, 0, True, scores, treeDepth)) 


2. Write a Python program to demonstrate List operations. 
# To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1) 


Slip 12. 
1. Write a Python program to implement Water jug problem having 2 jug with capacity 3 and 5 litre 
with unlimited water supply respectively. The target to achieve is 4 litre water in second jug. 
# Water Jug Problem using BFS 
# Jug A = 3 litres, Jug B = 5 litres 
# Goal: 4 litres in Jug B 
 
from collections import deque 
 
def water_jug(): 
    capacityA = 3 
    capacityB = 5 
    visited = set() 
 
    # Queue for BFS â†’ stores states (A, B) 
    queue = deque() 
    queue.append((0, 0))   # Initial state: both jugs empty 
    visited.add((0, 0)) 
 
    print("Steps to achieve 4 litres in Jug B:\n") 
 
    while queue: 
        A, B = queue.popleft() 
        print(f"({A}, {B})") 
 
        if B == 4:      # Goal reached 
            print("\nGoal achieved!") 
            break 
 
        # Generate all possible states 
 
        next_states = [ 
 
            (capacityA, B),    # Fill Jug A 
            (A, capacityB),    # Fill Jug B 
 
            (0, B),            # Empty Jug A 
            (A, 0),            # Empty Jug B 
 
            # Pour A -> B 
            (max(0, A - (capacityB - B)), min(capacityB, B + A)), 
 
            # Pour B -> A 
            (min(capacityA, A + B), max(0, B - (capacityA - A))) 
        ] 
 
        # Add new states to queue 
        for state in next_states: 
            if state not in visited: 
                visited.add(state) 
                queue.append(state) 
 
 
water_jug() 


 
2. Write a Program to Implement Tie Tac Toe problem 
board=["-","-","-","-","-","-","-","-","-",]  
def printb():  
 print(board[0]+"|"+board[1]+"|"+board[2])  
 print("-"*6)  
 print(board[3]+"|"+board[4]+"|"+board[5])  
 print("-"*6)  
 print(board[6]+"|"+board[7]+"|"+board[8])  
   
def start():  
 player='X'  
 go=False  
 while not go:  
  printb()  
  take_turn(player)  
  result=game_over()  
  if result=="WIN":  
     
   print(player+"win")  
   go=True  
  if result=="Tie":  
     
   print("Tie")  
   go=True  
  else:  
if player=="X":  
player="O"  
else:  
player="X"  
def game_over():  
if(board[0]==board[1]==board[2]!="-")or(board[3]==board[4]==board[5]!=" 
")or(board[6]==board[7]==board[8]!="-")or(board[0]==board[3]==board[6]!=" 
")or(board[1]==board[4]==board[7]!="-")or(board[2]==board[5]==board[8]!=" 
")or(board[0]==board[4]==board[8]!="-")or(board[2]==board[4]==board[6]!="-"):  
return "WIN"  
if "-" not in board:  
return"Tie"  
else:  
return "play"  
def take_turn(player):  
pos=input("enter position between1-9:-")  
while pos not in["1","2","3","4","5","6","7","8","9"]:  
pos=input("enter valid position:-")  
pos=int(pos)-1  
while board[pos]!="-":  
pos=input("enter  new position between1-9:-")  
board[pos]=player  
start() 


Slip 13. 
1. Write a Python program to demonstrate operation on list 
# To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1) 


2. Write a Program to Implement mini max algorithm consider your own graph 
def minimax (curDepth, nodeIndex,maxTurn, scores, targetDepth):  
if (curDepth == targetDepth):   
return scores[nodeIndex]  
if (maxTurn):  
return max(minimax(curDepth + 1, nodeIndex * 2, False, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, False, scores, targetDepth))  
else:  
return min(minimax(curDepth + 1, nodeIndex * 2, True, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, True, scores, targetDepth))  
scores = [3, 5, 2, 9, 12, 5, 23, 23]  
treeDepth = math.log(len(scores), 2)  
print("The optimal value is : ", end = "")  
print(minimax(0, 0, True, scores, treeDepth)) 


Slip 14. 
1. Write a python program for cryptarithmetic problem GO+TO=OUT 
def solve1():  
for g in range(1, 10):  
for o in range(0, 10):  
for t in range(0, 10):  
                for u in range(0, 10):  
                    if distinct(g, o, t, u):  
                      go = 10 * g + o  
                      to = 10 * t + o  
                      out = 100 * o + 10 * u + t  
                      if go + to == out:  
                        print(go, to, out)  
  
  
def distinct(*args):  
    return len(set(args)) == len(args)  
solve1() 


2. Write a python program to implement minimax algorithm 
def minimax (curDepth, nodeIndex,maxTurn, scores, targetDepth):  
if (curDepth == targetDepth):   
return scores[nodeIndex]  
if (maxTurn):  
return max(minimax(curDepth + 1, nodeIndex * 2, False, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, False, scores, targetDepth))  
else:  
return min(minimax(curDepth + 1, nodeIndex * 2, True, scores, targetDepth),   
minimax(curDepth + 1, nodeIndex * 2 + 1, True, scores, targetDepth))  
scores = [3, 5, 2, 9, 12, 5, 23, 23]  
treeDepth = math.log(len(scores), 2)  
print("The optimal value is : ", end = "")  
print(minimax(0, 0, True, scores, treeDepth))
