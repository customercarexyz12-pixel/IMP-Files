1.	Write a Python program to implement Depth First Search algorithm. Refer the following graph as an Input for the program. [Initial node=1,Goal node=8].
Solution: graph = {1:[2,3], 2:[4,5], 3:[6], 4:[7], 5:[], 6:[8], 7:[], 8:[]}
def dfs(g, start, goal):
    stack, visited = [start], []
    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            print("Visited:", n)
            if n == goal:
                print("\nGoal found!")
                return visited
            stack += reversed(g[n])
    print("Goal not found!")
    return visited
print("Depth First Search Traversal:")
path = dfs(graph, 1, 8)
print("\nTraversal Path:", path)

2.	Write a python program to implement minimax algorithm.
Solution:- def win(b, p):
    w = [[b[0][0],b[0][1],b[0][2]],
         [b[1][0],b[1][1],b[1][2]],
         [b[2][0],b[2][1],b[2][2]],
         [b[0][0],b[1][0],b[2][0]],
         [b[0][1],b[1][1],b[2][1]],
         [b[0][2],b[1][2],b[2][2]],
         [b[0][0],b[1][1],b[2][2]],
         [b[2][0],b[1][1],b[0][2]]]
    return [p,p,p] in w

def minimax(b, turn):
    if win(b,"X"): return 1
    if win(b,"O"): return -1
    if all(c!="_" for r in b for c in r): return 0

    scores=[]
    p="X" if turn else "O"

    for i in range(3):
        for j in range(3):
            if b[i][j]=="_":
                b[i][j]=p
                scores.append(minimax(b, not turn))
                b[i][j]="_"

    return max(scores) if turn else min(scores)

board=[["X","O","_"],
       ["_","O","_"],
       ["_","_","X"]]

print("Best score for X =", minimax(board, True))

3.	Write a Python program to demonstrate List operations.
Solution:- # To create list  
list1 = [1,2,3,4]  
print("List: ", list1)  
# Convert into list   
name = "HvDesai"  
list2 = list(name)  
print(f"{name} converted into list : {list2}")  
# get length of the list using len() function  
list3 = [1,3,4,5,6,7,8]  
print(f"Length of the list: {len(list3)}")  
# check the type of the list using type() function  
print(f"Type of the list: {type(list3)}")  
# A list with strings, integers and boolean values:  
list4 = [1,3, 'name', True]  
list1 = ["Amit", "Tejas", "Sahil", "Yash"]  
# Access Items  
print(list1[2]) # O/p = Sahil  
# Adding element in list using append()  
list1.append("Avi")  
print(list1)  
# Removing last element from the list  
list1.pop()  
print(list1)  
# To insert a list item at a specified index, use the insert() method.  
list1.insert(2, "Sam")  
print(list1)  
# The remove() method removes the specified item.  
list1.remove("Sam")  
print(list1)  
# Sort the list  
list1 = [4,1,2,9,3]  
list1.sort()  
print(list1)




4.	Write a python program implement tic-tac-toe..
Solution: b=[" "]*9
def show():
  	  print(b[0],b[1],b[2])
    	print(b[3],b[4],b[5])
   	 print(b[6],b[7],b[8])
def win(p):
    w=[[0,1,2],[3,4,5],[6,7,8],
       [0,3,6],[1,4,7],[2,5,8],
       [0,4,8],[2,4,6]]
    return any(b[x]==b[y]==b[z]==p for x,y,z in w)
p="X"
for _ in range(9):
    show()
    m=int(input(f"Player {p} move (0-8): "))
    if b[m]==" ":
        b[m]=p
        if win(p):
            show()
            print(p,"wins!")
            break
        p="O" if p=="X" else "X"
    else:
        print("Invalid move!")
else:
    show()
    print("Draw!")


5.	Write a python program to implement tower of Hanoi.
Solution: def toh(disks, source, auxiliary, target):
    if disks == 1:
        print(f"Move disk 1 from rod {source} to rod {target}.")
        return
    toh(disks - 1, source, target, auxiliary)
    print(f"Move disk {disks} from rod {source} to rod {target}.")
    toh(disks - 1, auxiliary, source, target)
disks = int(input("Enter the number of disks: "))
toh(disks, 'A', 'B', 'C').

6.	Write a python program to implement cryptarithmetic problem SEND+MORE=MONEY.
Solution: from itertools import permutations

def solve_cryptarithm():
    letters = ('S','E','N','D','M','O','R','Y')
    digits = (0,1,2,3,4,5,6,7,8,9)

    for perm in permutations(digits, len(letters)):
        mapping = dict(zip(letters, perm))

        # Leading letters cannot be zero
        if mapping['S'] == 0 or mapping['M'] == 0:
            continue

        SEND = 1000*mapping['S'] + 100*mapping['E'] + 10*mapping['N'] + mapping['D']
        MORE = 1000*mapping['M'] + 100*mapping['O'] + 10*mapping['R'] + mapping['E']
        MONEY = 10000*mapping['M'] + 1000*mapping['O'] + 100*mapping['N'] + 10*mapping['E'] + mapping['Y']

        if SEND + MORE == MONEY:
            print("Solution Found!")
            print("Mapping:", mapping)
            print("SEND =", SEND)
            print("MORE =", MORE)
            print("MONEY =", MONEY)
            return

solve_cryptarithm()

7.	Write a python program to implement cryptarithmetic problem BASE + BALL = GAMES.
Solutioon: from itertools import permutations

def solve_cryptarithm():
    letters = ('B','A','S','E','L','G','M')
    digits = range(10)

    for perm in permutations(digits, len(letters)):
        m = dict(zip(letters, perm))

        # Leading letters cannot be zero
        if m['B'] == 0 or m['G'] == 0:
            continue

        BASE  = 1000*m['B'] + 100*m['A'] + 10*m['S'] + m['E']
        BALL  = 1000*m['B'] + 100*m['A'] + 10*m['L'] + m['L']
        GAMES = 10000*m['G']+1000*m['A']+100*m['M']+10*m['E']+m['S']

      	  if BASE + BALL == GAMES:
            print("Solution Found!")
            print("Mapping:", m)
            print("BASE =", BASE)
            print("BALL =", BALL)
            print("GAMES =", GAMES)
return
solve_cryptarithm()

8.	Write a Python program to demonstrate Set operations.
Solution: # Create a Set:
thisset = {"apple", "banana", "cherry"}
print(thisset)
# Find length of the set using len() function
print(len(thisset))
# Add an item to a set, using the add() method:
thisset = {"apple", "banana", "cherry"}
thisset.add("orange")
print(thisset)
# Add elements from tropical into thisset:
thisset = {"apple", "banana", "cherry"}
tropical = {"pineapple", "mango", "papaya"}
thisset.update(tropical)
print(thisset)
# Remove "banana" by using the remove() method:
thisset = {"apple", "banana", "cherry"}
thisset.remove("banana")
print(thisset)
# Set intersection() Method
x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}
z = x.intersection(y)
print(z)
# Set union() Method
x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}
z = x.union(y)
print(z)  
# Set issubset() Method  
x = {"a", "b", "c"}  
y = {"f", "e", "d", "c", "b", "a"}  
z = x.issubset(y)  
print(z)











