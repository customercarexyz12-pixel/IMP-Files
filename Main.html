Slip 1.
1.	Take multiple files as Command Line Arguments and print their inode numbers and file types.

#include<stdlib.h> 
#include<stdio.h> 
#include<string.h> 
main(int argc, char *argv[]) 
{ 
char d[50]; 
if(argc==2) 
{ 
bzero(d,sizeof(d)); 
strcat(d,"ls "); 
strcat(d,"-i "); 
strcat(d,argv[1]); 
system(d); 
} 
else 
printf("\nInvalid No. of inputs"); 
} 
output:
create txt file

1. gcc A1.c
2../a.out File1.txt 
3. cat File1.txt 

2.	Write a C program to send SIGALRM signal by child process to parent process and parent process make a provision to catch the signal and display alarm is fired.(Use Kill, fork, signal and sleep system call).
Solution:- 
		#include <fcntl.h> 
    #include <unistd.h>
    #include <stdio.h>
    #include<signal.h>
    #include<sys/types.h>
    #include<sys/wait.h>
    #include <stdlib.h> 
void Dingdong()
{ 
printf("Ding!"); 
exit(1); 
} 
int main(int argc, char *argv[]) 
{ 
if(argc!=2) 
{ 
printf("How much seconds you want to sleep the child process\n"); 
} 
int PauseSecond=(argv[1]); 
{ 
if(fork()==0) 
{ 
printf("waiting for alarm to go off\n"); 
printf("%d second pause",PauseSecond); 
sleep(PauseSecond); 
kill(getpid(),SIGALRM); 
} 
else { 
printf("Alarm application starting\n", getpid()); 
signal(SIGALRM,Dingdong); 
printf("done"); 
} 
} 
}

Slip 2
1.	Write a C program to find file properties such as inode number, number of hard link, File permissions, File size, File access and modification time and so on of a given file using stat() system call.
Solution:-

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<dirent.h>
#include<string.h>
#include<time.h>
#include<pwd.h>
#include<grp.h>

int main()
{
 char fn[50],s[500]; 
 struct passwd *pw; 
 struct group *gr; 
 struct stat s1; 
  
 printf("Give File nAME"); 
 gets(fn); 
  
 stat(fn,&s1); 
 if(S_ISREG(s1.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s1.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s1.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s1.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBLK(s1.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s1.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s1.st_mode)) 
  printf(" Link File"); 
   
 printf("\n File permission"); 
 printf((s1.st_mode & S_IRUSR)?"r":"-"); 
 printf((s1.st_mode & S_IWUSR)?"w":"-"); 
 printf((s1.st_mode & S_IXUSR)?"x":"-"); // user per 
  
 printf((s1.st_mode & S_IRGRP)?"r":"-"); 
 printf((s1.st_mode & S_IWGRP)?"w":"-"); 
 printf((s1.st_mode & S_IXGRP)?"x":"-");// group per 
  
 printf((s1.st_mode & S_IROTH)?"r":"-"); 
 printf((s1.st_mode & S_IWOTH)?"w":"-"); 
 printf((s1.st_mode & S_IXOTH)?"x":"-");// other per 
  
 printf("\n Inode Number=.%d",s1.st_ino); // inode number 
  
 printf("\n Number of link=%d",s1.st_nlink); // number of link 
 printf("\n size of file=.%d",s1.st_size); // Size 
 strcpy(s,ctime(&s1.st_ctime)); 
 printf("\n Creation Time.%s",s); //  creatin time 
  
 strcpy(s,ctime(&s1.st_atime)); 
 printf("\n A Time.%s",s); //  access time 
  
 strcpy(s,ctime(&s1.st_mtime)); 
 printf("\n M Time.%s",s); //  modify time 
  
 printf("\nUsr id:",s1.st_uid);// User id with user name 
 pw=getpwuid(s1.st_uid); 
 printf("User name:%s",pw->pw_name); 
  
 printf("\ngroup id:",s1.st_gid);// Group id with group name 
 gr=getgrgid(s1.st_gid); 
 printf("Group name:%s",gr->gr_name); 
  
 return 0; 
}

2.	Write a C program that catches the ctrl-c (SIGINT) signal for the first time and display the appropriate message and exits on pressing ctrl-c again.
Solution:- #include <stdio.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
void sigfun(int sig)
{ 
printf("You have presses Ctrl-C , please press again to exit"); 
(void) signal(SIGINT, SIG_DFL); 
} 
int main() 
{ 
(void) signal(SIGINT, sigfun); 
while(1) { 
printf("Hello World! 
"); 
sleep(1); 
} 
return(0); 
}




Slip 3.
1.	Print the type of file and inode number where file name accepted through Command Line
Solution:- #include<stdlib.h> 
#include<stdio.h> 
#include<string.h> 
main(int argc, char *argv[]) 
{ 
char d[50]; 
if(argc==2) 
{ 
bzero(d,sizeof(d)); 
strcat(d,"ls "); 
strcat(d,"-i "); 
strcat(d,argv[1]); 
system(d); 
} 
else 
printf("\nInvalid No. of inputs"); 
} 
output: 
student@ubuntu:~$ mkdir dd 
student@ubuntu:~$ cd dd 
student@ubuntu:~/dd$ cat >f1 
hello 
^z 
student@ubuntu:~/dd$ cd 
student@ubuntu:~$gcc –o flist.out flist.c 
student@ubuntu:~$./flist.out dd 
hello 
46490 f1.
2.	Write a C program which creates a child process to run linux/ unix command or any user defined program. The parent process set the signal handler for death of child signal and Alarm signal. If a child process does not complete its execution in 5 second then parent process kills child process.
Solution: // C program to implement sighup(), sigint() 
// and sigquit() signal functions 
#include <signal.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 

 
// function declaration 
void sighup(); 
void sigint(); 
void sigquit();  
// driver code 
void main() 
{ 
    int pid; 
    /* get child process */ 
    if ((pid = fork()) < 0) { 
        perror("fork"); 
        exit(1); 
    } 
    if (pid == 0) { /* child */ 
        signal(SIGHUP, sighup); 
        signal(SIGINT, sigint); 
        signal(SIGQUIT, sigquit); 
        for (;;) 
            ; /* loop for ever */ 
    } 
    else /* parent */ 
    { /* pid hold id of child */ 
        printf("\nPARENT: sending SIGHUP\n\n"); 
        kill(pid, SIGHUP); 
        sleep(3); /* pause for 3 secs */ 
        printf("\nPARENT: sending SIGINT\n\n"); 
        kill(pid, SIGINT); 
        sleep(3); /* pause for 3 secs */ 
        printf("\nPARENT: sending SIGQUIT\n\n"); 
        kill(pid, SIGQUIT); 
        sleep(3); 
    } 
}   
// sighup() function definition 
void sighup() 
{ 
    signal(SIGHUP, sighup); /* reset signal */ 
    printf("CHILD: I have received a SIGHUP\n"); 
}
// sigint() function definition 
void sigint() 
{ 
    signal(SIGINT, sigint); /* reset signal */ 
    printf("CHILD: I have received a SIGINT\n"); 
}  
// sigquit() function definition 
void sigquit() 
{ 
    printf("My DADDY has Killed me!!!\n"); 
    exit(0); 
}.

Slip 4. 
1.	Write a C program to find whether a given files passed through command line arguments are present in current directory or not.
Solution: 
	#include<stdio.h> 
#include<unistd.h> 
int main(int argc,char *argv[]) 
{ 
if(access(argv[1],F_OK)==0) 
printf("File %s exists.",argv[1]); 
else 
printf("File not exists."); 
return 0; 
}

2.	Write a C program which creates a child process and child process catches a signal SIGHUP, SIGINT and SIGQUIT. The Parent process send a SIGHUP or SIGINT signal after every 3 seconds, at the end of 15 second parent send SIGQUIT signal to child and child terminates by displaying message "My Papa has Killed me!!!”.
Solution:- // C program to implement sighup(), sigint() 
// and sigquit() signal functions 
#include <signal.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 
// function declaration 
void sighup(); 
void sigint(); 
void sigquit(); 
// driver code 
void main() 
{ 
int pid; 
/* get child process */ 
if ((pid = fork()) < 0) { 
  perror("fork"); 
  exit(1); 
 } 
 
 if (pid == 0) { /* child */ 
  signal(SIGHUP, sighup); 
  signal(SIGINT, sigint); 
  signal(SIGQUIT, sigquit); 
  for (;;) 
   ; /* loop for ever */ 
 } 
 
 else /* parent */ 
 { /* pid hold id of child */ 
  printf("\nPARENT: sending SIGHUP\n\n"); 
  kill(pid, SIGHUP); 
 
  sleep(3); /* pause for 3 secs */ 
  printf("\nPARENT: sending SIGINT\n\n"); 
  kill(pid, SIGINT); 
 
  sleep(3); /* pause for 3 secs */ 
  printf("\nPARENT: sending SIGQUIT\n\n"); 
  kill(pid, SIGQUIT); 
  sleep(3); 
 } 
} 
 
// sighup() function definition 
void sighup() 
 
{ 
 signal(SIGHUP, sighup); /* reset signal */ 
 printf("CHILD: I have received a SIGHUP\n"); 
} 
 
// sigint() function definition 
void sigint() 
 
{ 
signal(SIGINT, sigint); /* reset signal */ 
printf("CHILD: I have received a SIGINT\n"); 
} 
// sigquit() function definition 
void sigquit() 
{ 
printf("My DADDY has Killed me!!!\n"); 
exit(0); 
}



Slip 5.
1.	Read the current directory and display the name of the files, no of files in current directory.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
 
int main() 
{ 
 DIR *d; 
 struct dirent *dr;  
 int c=0; 
 d=opendir("."); 
 while(dr=readdir(d)) 
 { 
  printf("\n %s",dr-> d_name); 
  c++; 
 } 
 
 printf("Count of file %d:",c); 
  closedir(d); 
 return 0; 
}
2.	Write a C program to create an unnamed pipe. The child process will write following three messages to pipe and parent process display it. Message1 = “Hello World” Message2 = “Hello SPPU” Message3 = “Linux is Funny”.
Solution: 
#include<stdio.h> 
#include<unistd.h> 
int main() { 
int pipefds[2]; 
int returnstatus; 
char writemessages[3][20]={"Hello World", "Hello SPPU","Linux is Funny"}; 
char readmessage[20]; 
returnstatus = pipe(pipefds); 
if (returnstatus == -1) { 
printf("Unable to create pipe\n"); 
return 1; 
} 
int child = fork(); 
if(child==0){ 
printf("Child is Writing to pipe - Message 1 is %s\n", writemessages[0]); 
write(pipefds[1], writemessages[0], sizeof(writemessages[0])); 
printf("Child is Writing to pipe - Message 2 is %s\n", writemessages[1]); 
write(pipefds[1], writemessages[1], sizeof(writemessages[1])); 
printf("Child is Writing to pipe - Message 3 is %s\n", writemessages[2]); 
write(pipefds[1], writemessages[2], sizeof(writemessages[2])); 
} 
else 
{ 
read(pipefds[0], readmessage, sizeof(readmessage)); 
printf("Parent Process is Reading from pipe – Message 1 is %s\n", 
readmessage); 
read(pipefds[0], readmessage, sizeof(readmessage)); 
printf("Parent Process is Reading from pipe – Message 2 is %s\n", 
readmessage); 
read(pipefds[0], readmessage, sizeof(readmessage)); 
printf("Parent Process is Reading from pipe – Message 3 is %s\n", 
readmessage); 
} 
return 0; 
}

Slip 6. 
1.	Display all the files from current directory which are created in particular month.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
 int main() 
 { 
  char m[50]; 
  char s[500]; 
  DIR *d; 
  struct stat s1; 
  struct dirent *dr; 
   
  printf("\n Enter month:"); 
  gets(m); 
  d=opendir("."); 
  while(dr=readdir(d)) 
   { 
    stat(dr->d_name,&s1); 
    strcpy(s,ctime(&s1.st_ctime)); 
    if(strstr(s,m)) 
     printf("%s",dr->d_name); 
     
   }   
  close(d); 
  return 0; 
  
 }

2.	Write a C program to create n child processes. When all n child processes terminates, Display total cumulative time children spent in user and kernel mode.
Solution: #include<sys/times.h> 
#include<time.h> 
#include<stdio.h> 
#include<unistd.h> 
#include<sys/wait.h> 
 
int main() 
{ 
 struct tms t; 
 int c,n,s; 
 long int i,j; 
 double d,ut,st,cut,cst; 
  
 printf("Enter Number of process:"); 
 scanf("%d",&n); 
  
 while(n-- >0) 
 { 
  c=fork(); 
  if(c==0) 
  { 
   printf("\n process id=>%d",getpid()); 
   for(i=0,j>0;i<=10000000;i++) 
   j++; 
   exit(0); 
  } 
  else 
  { 
   wait(&s); 
  } 
 } 
 d=sysconf(_SC_CLK_TCK); 
 times(&t); 
 ut=t.tms_utime/d; 
 st=t.tms_stime/d; 
 cut=t.tms_cutime/d; 
 cst=t.tms_cstime/d; 
  
 printf("\nuser time:-%lf",ut); 
 printf("\nSystem time:-%lf",st); 
 printf(" \nchild user time:-%lf",cut); 
 printf(" \nchild System time:-%lf",cst); 
 return 0; 
}
Slip 7.
1.	Write a C Program that demonstrates redirection of standard output to a file.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
int main() 
{ 
 int fd1,fd2; 
 fd1=open("output.txt",O_WRONLY|O_CREAT,0666); 
 printf("\nNormal output:"); 
 fflush(stdout); 
  
 fd2=dup(1); 
 dup2(fd1,1); 
 printf("\n Atharav Nijampurkar"); 
 printf("\n h.v.deasi clg"); 
  
 close(fd1); 
 fflush(stdout); 
 dup2(fd2,1); 
 printf("\nAgain Normal"); 
 return 0; 
  
}

2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { 
  close(p[1]); 
  close(0); 
  dup(p[0]); 
  close(p[0]); 
  execlp("wc","wc","-l",NULL); 
 }  
 return 0; 
  
}

Slip 8. 
1.	Write a C program that redirects standard output to a file output.txt. (use of dup and open system call).
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
int main() 
{ 
 int fd1,fd2; 
 fd1=open("output.txt",O_WRONLY|O_CREAT,0666); 
 printf("\nNormal output:"); 
 fflush(stdout); 
  
 fd2=dup(1); 
 dup2(fd1,1); 
 printf("\n Atharav Nijampurkar"); 
 printf("\n h.v.deasi clg"); 
  
 close(fd1); 
 fflush(stdout); 
 dup2(fd2,1); 
 printf("\nAgain Normal"); 
 return 0; 
  
}
2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { 
  close(p[1]); 
  close(0); 
  dup(p[0]); 
  close(p[0]); 
  execlp("wc","wc","-l",NULL); 
 }  
 return 0; 
  
}

Slip 9.
1.	Generate parent process to write unnamed pipe and will read from it.
Solution: #include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2]; 
 int n,i; 
 char *m1="Atharav Nijampurkar\n"; 
 char *m2="photographer\n"; 
 char *m3="pune\n"; 
 char s[50]; 
 pipe(p); 
 n=fork(); 
 if(n==0) 
 { 
  write(p[1],m1,strlen(m1)); 
  write(p[1],m2,strlen(m1)); 
  write(p[1],m3,strlen(m1)); 
 } 
 else 
 { 
  printf("\n In Parent!!!!"); 
  for(i=0;i<3;i++) 
  { 
   read(p[0],s,100); 
   printf("%s",s); 
  } 
  
 } 
 
return 0; 
 
}.

2.	Write a C program to Identify the type (Directory, character device, Block device, Regular file, FIFO or pipe, symbolic link or socket) of given file using stat() system call.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
 
int main( int argc,char *argv[]) 
 { 
  struct stat s; 
 int i; 
 if(argc<=0) 
 { 
  printf("Give File nAME"); 
  exit(0); 
 } 
 stat(argv[i],&s); 
 if(S_ISREG(s.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBL///K(s.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s.st_mode)) 
  printf(" Link File"); 
   
 return 0; 
}

Slip 10
1.	Write a program that illustrates how to execute two commands concurrently with a pipe.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ char s[80]; 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { wait(); 
  printf("Im in parent"); 
  while(read(p[0],s,80)) 
  printf("%s",s); 
  exit(n); 
 } 
  
 return 0; 
  
}

2.	Generate parent process to write unnamed pipe and will write into it. Also generate child process which will read from pipe.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2]; 
 int n,i; 
 char *m1="Atharav Nijampurkar\n"; 
 char *m2="photographer\n"; 
 char *m3="pune\n"; 
 char s[50]; 
 pipe(p); 
 n=fork(); 
 if(n==0) 
 { 
  write(p[1],m1,strlen(m1)); 
  write(p[1],m2,strlen(m1)); 
  write(p[1],m3,strlen(m1)); 
 } 
 else 
 { 
  printf("\n In Parent!!!!"); 
  for(i=0;i<3;i++) 
  { 
   read(p[0],s,100); 
   printf("%s",s); 
  } 
  
 } 
 
return 0; 
 
}







Slip 11

1.	Write a C program to get and set the resource limits such as files, memory associated with a process.
Solution:- #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<sys/wait.h> 
#include<sys/resource.h> 
int main() 
{ 
struct rlimit a,b,c; 
getrlimit(RLIMIT_DATA,&a); 
printf("\nrlim_cur=%d",a.rlim_cur); 
printf("\nrlim_max=%d",a.rlim_max); 
b.rlim_cur=10; 
b.rlim_max=1000; 
setrlimit(RLIMIT_DATA,&b); 
getrlimit(RLIMIT_DATA,&c); 
printf("\nrlim_cur=%d",c.rlim_cur); 
printf("\nrlim_max=%d",c.rlim_max); 
printf("\nfilesize=>"); 
getrlimit(RLIMIT_STACK,&a); 
printf("\nrlim_cur=%d",a.rlim_cur); 
printf("\nrlim_max=%d",a.rlim_max); 
b.rlim_cur=20; 
b.rlim_max=2000; 
setrlimit(RLIMIT_STACK,&b); 
getrlimit(RLIMIT_STACK,&c); 
printf("\nrlim_cur=%d",c.rlim_cur); 
printf("\nrlim_max=%d",c.rlim_max); 
return 0; 
}

2.	Write a C program that redirects standard output to a file output.txt. (use of dup and open system call).
Solution:- 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
int main() 
{ 
 int fd1,fd2; 
 fd1=open("output.txt",O_WRONLY|O_CREAT,0666); 
 printf("\nNormal output:"); 
 fflush(stdout); 
  
 fd2=dup(1); 
 dup2(fd1,1); 
 printf("\n Atharav Nijampurkar"); 
 printf("\n h.v.deasi clg"); 
  
 close(fd1); 
 fflush(stdout); 
 dup2(fd2,1); 
 printf("\nAgain Normal"); 
 return 0; 
  
}

Slip 12

1.	Write a C program that print the exit status of a terminated child process.
Solution: 
#include<sys/times.h> 
#include<time.h> 
#include<stdio.h> 
#include<unistd.h> 
#include<sys/wait.h> 
 
int main() 
{ 
 int n,s,c; 
 c=fork(); 
 if(c==0) 
 { 
  execlp("date","date",NULL); 
   
 } 
 else 
 { 
  waitpid(c,&s,WNOHANG); 
  if(WIFEXITED(s)) 
  { 
   printf("\n Exit status=>%d",WEXITSTATUS(s)); 
  } 
 } 
 return 0; 
}
2.	Write a C program which receives file names as command line arguments and display those filenames in ascending order according to their sizes. I) (e.g $ a.out a.txt b.txt c.txt, …).
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main(int argc,char *argv[]) 
{ char t[100]; 
 struct stat s1,s2; 
 int i,j; 
 if(argc<=0) 
 { 
  printf("Give File nAME"); 
  exit(0); 
 } 
 for(i=1;i<=argc;i++) 
  for(j=i+1;j<=argc;j++) 
  { 
   stat(argv[i],&s1); 
   stat(argv[j],&s2); 
   if(s1.st_size>s2.st_size) 
   { 
    strcpy(t,argv[i]); 
    strcpy(argv[i],argv[j]); 
    strcpy(argv[j],t); 
   } 
    
  } 
 printf("\n File in ascend order:"); 
 for(i=1;i<=argc;i++) 
  { 
   stat(argv[i],&s1); 
   printf("\n %s\t%d",argv[i],s1.st_size); 
  } 
  return 0; 
}

Slip 13

1.	Write a C program that illustrates suspending and resuming processes using signals.
Solution:- #include<stdio.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<signal.h> 
void sh1(); 
void sh2(); 
void sh3(); 
int main() 
{ 
printf("\nIn main Program"); 
signal(SIGTSTP,sh1); 
signal(SIGCONT,sh2); 
signal(SIGINT,sh3); 
while(1) 
{ 
sleep(2); 
raise(SIGTSTP); 
sleep(2); 
raise(SIGCONT); 
} 
return 0; 
} 
void sh1() 
{ 
printf("\nSuspend"); 
} 
void sh2() 
{ 
printf("\nResume"); 
} 
void sh3() 
{ 
printf("\nIntrupted"); 
exit(0); 
}

2.	Write a C program that a string as an argument and return all the files that begins with that name in the current directory. For example > ./a.out foo will return all file names that begins with foo.
Solution:  #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
 
int main( int argc,char *argv[]) 
{ 
 DIR *d; 
  struct dirent *dr;  
  char t[50]; 
  d=opendir("."); 
  if(argc<=1) 
  { 
   printf("Enter name"); 
   exit(0); 
  } 
  while(dr=readdir(d)) 
  { 
  strncpy(t,dr->d_name,strlen(argv[1])); 
  if(strcmp(t,argv[1])==0) 
   printf("\n%s",dr->d_name); 
   
  } 
  closedir(d); 
  return 0;  
 
}

Slip 14

1.	Display all the files from current directory whose size is greater that n Bytes Where n is accept from user.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
 int main() 
 { 
  char m[50]; 
  int n; 
  DIR *d; 
  struct stat s1; 
  struct dirent *dr; 
   
  printf("\n Enter Size:"); 
  scanf("%d",&n); 
  d=opendir("."); 
  while(dr=readdir(d)) 
   { 
    stat(dr->d_name,&s1); 
     
    if(s1.st_size>n) 
     printf("%s",dr->d_name); 
   } 
  close(d); 
  return 0; 
  
 }
2.	Write a C program to find file properties such as inode number, number of hard link, File permissions, File size, File access and modification time and so on of a given file using stat() system call.
Solution:  
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
#include<pwd.h> 
#include<grp.h> 
 
int main() 
{ 
 char fn[50],s[500]; 
 struct passwd *pw; 
 struct group *gr; 
 struct stat s1; 
  
 printf("Give File nAME"); 
 gets(fn); 
  
 stat(fn,&s1); 
 if(S_ISREG(s1.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s1.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s1.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s1.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBLK(s1.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s1.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s1.st_mode)) 
  printf(" Link File"); 
   
 printf("\n File permission"); 
 printf((s1.st_mode & S_IRUSR)?"r":"-"); 
 printf((s1.st_mode & S_IWUSR)?"w":"-"); 
 printf((s1.st_mode & S_IXUSR)?"x":"-"); // user per 
  
 printf((s1.st_mode & S_IRGRP)?"r":"-"); 
 printf((s1.st_mode & S_IWGRP)?"w":"-"); 
 printf((s1.st_mode & S_IXGRP)?"x":"-");// group per 
  
 printf((s1.st_mode & S_IROTH)?"r":"-"); 
 printf((s1.st_mode & S_IWOTH)?"w":"-"); 
 printf((s1.st_mode & S_IXOTH)?"x":"-");// other per 
  
 printf("\n Inode Number=.%d",s1.st_ino); // inode number 
  
 printf("\n Number of link=%d",s1.st_nlink); // number of link 
  
 printf("\n size of file=.%d",s1.st_size); // Size 
  
 strcpy(s,ctime(&s1.st_ctime)); 
 printf("\n Creation Time.%s",s); //  creatin time 
  
 strcpy(s,ctime(&s1.st_atime)); 
 printf("\n A Time.%s",s); //  access time 
  
 strcpy(s,ctime(&s1.st_mtime)); 
 printf("\n M Time.%s",s); //  modify time 
  
 printf("\nUsr id:",s1.st_uid);// User id with user name 
 pw=getpwuid(s1.st_uid); 
 printf("User name:%s",pw->pw_name); 
  
 printf("\ngroup id:",s1.st_gid);// Group id with group name 
 gr=getgrgid(s1.st_gid); 
 printf("Group name:%s",gr->gr_name); 
  
 return 0; 
 
}

Slip 15

1.	Display all the files from current directory whose size is greater that n Bytes Where n is accept from user.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
 int main() 
 { 
  char m[50]; 
  int n; 
  DIR *d; 
  struct stat s1; 
  struct dirent *dr; 
   
  printf("\n Enter Size:"); 
  scanf("%d",&n); 
  d=opendir("."); 
  while(dr=readdir(d)) 
   { 
    stat(dr->d_name,&s1); 
     
    if(s1.st_size>n) 
     printf("%s",dr->d_name); 
   } 
  close(d); 
  return 0; 
  
 }

2.	Write a C program which creates a child process to run linux/ unix command or any user defined program. The parent process set the signal handler for death of child signal and Alarm signal. If a child process does not complete its execution in 5 second then parent process kills child process.
Solution. #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void sh1(); 
void main() 
{ 
 int n; 
 signal(SIGCHLD,sh1); 
 n=fork(); 
 if(n==0) 
 { 
  execlp("ls","ls","-l",NULL); 
   
   
 } 
 else 
 { 
  sleep(5); 
  printf("\n child exced time"); 
  kill(n,SIGINT); 
  fflush(stdout); 
  sleep(2); 
  
 } 
 return 0; 
 
} 
 
void sh1() 
{ 
 printf("\n child killed by parent"); 
 exit(0); 
 
}

Slip 16

1.	Display all the files from current directory which are created in particular month.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<time.h> 
 int main() 
 { 
  char m[50]; 
  char s[500]; 
  DIR *d; 
  struct stat s1; 
  struct dirent *dr; 
   
  printf("\n Enter month:"); 
  gets(m); 
  d=opendir("."); 
  while(dr=readdir(d)) 
   { 
    stat(dr->d_name,&s1); 
    strcpy(s,ctime(&s1.st_ctime)); 
    if(strstr(s,m)) 
     printf("%s",dr->d_name); 
     
   }   
  close(d); 
  return 0; 
  
 }

2.	Write a C program which create a child process which catch a signal sighup, sigint and sigquit. The Parent process send a sighup or sigint signal after every 3 seconds, at the end of 30 second parent send sigquit signal to child and child terminates my displaying message “My DADDY has Killed me!!!”.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void Sh1(); 
void Sh2(); 
void Sh3(); 
 
int main() 
{ 
 int n; 
 n=fork(); 
 if(n==0) 
 { 
  signal(SIGHUP,Sh1); 
  signal(SIGINT,Sh2); 
  signal(SIGQUIT,Sh3); 
  while(1) 
  { 
   
  } 
   
 } 
 else 
 { 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGHUP); 
  sleep(3); 
  kill(n,SIGINT); 
  sleep(3); 
  kill(n,SIGQUIT); 
  exit(0); 
 } 
 return 0; 
} 
 
void Sh1() 
{ 
 printf("\nSIGHUP Process"); 
 //fflush(stdout); 
 signal(SIGHUP,Sh1); 
} 
 
void Sh2() 
{ 
 printf("\n SIGINT Process"); 
 //fflush(stdout); 
 signal(SIGINT,Sh2); 
} 
 
void Sh3() 
{ 
 printf("\n My DADDY  Has Kill Me"); 
 exit(0); 
}

Slip 17
1.	Read the current directory and display the name of the files, no of files in current directory.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
 
int main() 
{ 
 DIR *d; 
 struct dirent *dr;  
 int c=0; 
 d=opendir("."); 
 while(dr=readdir(d)) 
 { 
  printf("\n %s",dr-> d_name); 
  c++; 
 } 
 
 printf("Count of file %d:",c); 
  closedir(d); 
 return 0; 
}

2.	Write a C program to implement the following unix/linux command (use fork, pipe and exec system call). Your program should block the signal Ctrl-C and Ctrl-\ signal during the execution. i. Ls –l | wc –l.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
#include<signal.h> 
 
void sh1(); 
void sh2(); 
int main() 
{ 
 int n,fd[2]; 
 pipe(fd); 
  
 signal(SIGINT,sh1); 
 signal(SIGQUIT,sh2); 
 n=fork(); // child parent tayar karnya sathi.. 
 if(n==0) 
 { 
  close(fd[0]); 
  close(1); 
  dup(fd[1]); 
  close(fd[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { 
  sleep(30); 
  close(fd[1]); 
  close(0); 
  dup(fd[0]); 
  close(fd[0]); 
  execlp("wc","wc","-l",NULL); 
   
 }  
return 0;  
} 
 
void sh1() 
{ 
 printf("\n cought clt+c"); 
 fflush(stdout); 
} 
 
void sh2() 
{ 
 printf("\n cought Quite"); 
 fflush(stdout); 
}

Slip 18

1.	Write a C program to find whether a given file is present in current directory or not.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
 int main() 
 { 
  char s[100]; 
  int fd; 
  printf("\n Enter file name"); 
  scanf("%s",&s); 
  fd=open(s,O_RDONLY); 
  if(fd<0) 
   printf("File not present"); 
  else 
   printf("File is present"); 
    
  close(fd); 
  return 0; 
 }


2.	Write a C program to create an unnamed pipe. The child process will write following three messages to pipe and parent process display it. Message1 = “Hello World” Message2 = “Hello SPPU” Message3 = “Linux is Funny”.
Solution: 	#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2]; 
 int n,i; 
 char *m1="Hello World\n"; 
 char *m2="Hello SPPU\n"; 
 char *m3="Linux is Funny\n"; 
 char s[50]; 
 pipe(p); 
 n=fork(); 
 if(n==0) 
 { 
  write(p[1],m1,strlen(m1)); 
  write(p[1],m2,strlen(m1)); 
  write(p[1],m3,strlen(m1)); 
 } 
 else 
 { 
  printf("\n In Parent!!!!"); 
  for(i=0;i<3;i++) 
  { 
   read(p[0],s,50); 
   printf("%s",s); 
  } 
  
 } 
 
return 0; 
 
}

Slip 19.
1.	Take multiple files as Command Line Arguments and print their file type and inode number.
Solution: 	#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
 
int main( int argc,char *argv[]) 
{ 
 struct stat s; 
 int i; 
 if(argc<=0) 
 { 
  printf("Give File nAME"); 
  exit(0); 
 } 
 for(i=1;i<=argc;i++) 
 { 
  stat(argv[i],&s); 
  printf("\n %s\t%d",argv[i],s.st_ino); 
 } 
 return 0; 
}

2.	Implement the following unix/linux command (use fork, pipe and exec system call) ls –l | wc –l.
Solution: #include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
#include<dirent.h> 
#include<string.h> 
 
int main() 
{ 
 int p[2],n; 
 pipe(p); 
  
 n=fork(); // child parent tayar karnya sathi.. 
  
 if(n==0) 
 { 
  close(p[0]); 
  close(1); 
  dup(p[1]); 
  close(p[1]); 
  execlp("ls","ls","-l",NULL); 
 }  
 else 
 { 
  close(p[1]); 
  close(0); 
  dup(p[0]); 
  close(p[0]); 
  execlp("wc","wc","-l",NULL); 
 }  
 return 0; 
  
}

Slip 20.

1.	Write a C program that illustrates suspending and resuming processes using signals.
Solution: #include<stdio.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<signal.h> 
void sh1(); 
void sh2(); 
void sh3(); 
int main() 
{ 
printf("\nIn main Program"); 
signal(SIGTSTP,sh1); 
signal(SIGCONT,sh2); 
signal(SIGINT,sh3); 
while(1) 
{ 
sleep(2); 
raise(SIGTSTP); 
sleep(2); 
raise(SIGCONT); 
} 
return 0; 
} 
void sh1() 
{ 
printf("\nSuspend"); 
} 
void sh2() 
{ 
printf("\nResume"); 
} 
void sh3() 
{ 
printf("\nIntrupted"); 
exit(0); 
}

2.	Write a C program to Identify the type (Directory, character device, Block device, Regular file, FIFO or pipe, symbolic link or socket) of given file using stat() system call.
Solution: 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/stat.h> 
#include<sys/types.h> 
 
int main( int argc,char *argv[]) 
 { 
  struct stat s; 
 int i; 
 if(argc<=0) 
 { 
  printf("Give File nAME"); 
  exit(0); 
 } 
 stat(argv[i],&s); 
 if(S_ISREG(s.st_mode)) 
  printf("Regular File"); 
 else if(S_ISDIR(s.st_mode)) 
  printf("Directory File"); 
 else if(S_ISFIFO(s.st_mode)) 
  printf("Pipe File"); 
 else if(S_ISSOCK(s.st_mode)) 
  printf("Scoket File"); 
 else if(S_ISBL///K(s.st_mode)) 
  printf("Block File"); 
 else if(S_ISCHR(s.st_mode)) 
  printf("Charactre File"); 
 else if(S_ISLNK(s.st_mode)) 
  printf(" Link File"); 
   
 return 0; 
}